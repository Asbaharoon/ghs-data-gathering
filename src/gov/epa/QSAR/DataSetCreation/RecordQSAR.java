package gov.epa.QSAR.DataSetCreation;

import java.io.FileOutputStream;
import java.io.OutputStream;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.List;

import org.apache.commons.text.StringEscapeUtils;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellStyle;
import org.apache.poi.ss.usermodel.Font;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.ss.util.CellRangeAddress;
import org.apache.poi.ss.util.CellReference;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import gov.epa.api.ExperimentalConstants;
import gov.epa.exp_data_gathering.parse.ExperimentalRecord;
import gov.epa.exp_data_gathering.parse.ExperimentalRecords;
import gov.epa.exp_data_gathering.parse.ParseUtilities;

public class RecordQSAR {
	
	public String id_physchem;//	Autonumbered record number for physchem data (generated by database later)
	public String id_record_source;//	Record number for reference that the physchem data came from (generated by database later- may only need for records from journal articles)
	
	public boolean usable;
	public String reason;
	
	//ID fields:
	public String casrn;//Chemical abstracts service number (only if provided by the reference)
	public String einecs;
	public String chemical_name;//	Most systematic name (only if provided in the reference)
	public String smiles;//Simplified Molecular Input Line Entry System for molecular structure (only if provided in the reference)
	public String source_name;
	public String url;
	public String date_accessed;
	
	public String property_name;//	Name of the property (use  "options_property_names" lookup table to consistently populate the field)

	public Double property_value_point_estimate_exp;// Point estimate of the property (when a single value is given)
	public String property_value_units_exp;//The units for the property value (convert to defined values in ExperimentalConstants class)
	
	public Double property_value_point_estimate_qsar;// Point estimate of the property (when a single value is given)
	public String property_value_units_qsar;//The units for the property value (convert to defined values in ExperimentalConstants class)
	
	public String pressure_mmHg;
	public Double temperature_C;
	public String pH;
	
	//DSSTox fields:
	public String dsstox_substance_id; //DSSTox substance identifier
	public String Substance_Name;
	public String Substance_CASRN;
	public String Substance_Type;
	public String Substance_Note;
	public String Structure_SMILES;
	public String Structure_InChI;
	public String Structure_InChIKey;
	public String Structure_Formula;
	public Double Structure_MolWt;
	public String Structure_SMILES_2D_QSAR;
	
	public final static String [] outputFieldNames = {"id_physchem",
			"usable",
			"reason",			
			"casrn",
			"einecs",
			"chemical_name",
			"smiles", 
			"dsstox_substance_id",
			"Substance_Name", "Substance_CASRN", "Substance_Type", "Substance_Note", "Structure_SMILES",
			"Structure_InChI", "Structure_InChIKey", "Structure_Formula", "Structure_MolWt", "Structure_SMILES_2D_QSAR",
			"property_value_point_estimate_qsar",
			"property_value_units_qsar",
			"pressure_mmHg",
			"temperature_C",
			"pH",
			"url",
			"date_accessed"};
	
	public static List<RecordQSAR> getValidQSARRecordsFromExperimentalRecords(ExperimentalRecords expRecords) {
		List<RecordQSAR> qsarRecords = new ArrayList<RecordQSAR>();
		for (ExperimentalRecord er:expRecords) {
			if (!er.keep) {
				continue;
			} else if (!isValidPointEstimatePossible(er)) {
				continue;
			} else {
				RecordQSAR qr = getQSARRecordFromExperimentalRecord(er);
				qsarRecords.add(qr);
			}
		}
		return qsarRecords;
	}
	
	public static RecordQSAR getQSARRecordFromExperimentalRecord(ExperimentalRecord er) {
		RecordQSAR qr = new RecordQSAR();
		qr.usable = true;
		
		qr.id_physchem = er.id_physchem;
		qr.id_record_source = er.id_record_source;
		
		qr.casrn = er.casrn;
		qr.einecs = er.einecs;
		qr.chemical_name = er.chemical_name;
		qr.smiles = er.smiles;
		qr.dsstox_substance_id = er.dsstox_substance_id;
		qr.source_name = er.source_name;
		qr.url = er.url;
		qr.date_accessed = er.date_accessed;
		qr.property_name = er.property_name;
		qr.pressure_mmHg = er.pressure_mmHg;
		qr.temperature_C = er.temperature_C;
		qr.pH = er.pH;
		
		qr.property_value_units_exp = er.property_value_units_final;
		qr.property_value_point_estimate_exp = er.property_value_point_estimate_final==null ? rangeAverage(er) : er.property_value_point_estimate_final;
		
		return qr;
	}
	
	private static boolean isValidPointEstimatePossible(ExperimentalRecord er) {
		if (er.property_value_numeric_qualifier!=null && !er.property_value_numeric_qualifier.equals("~")) { return false; }
		if (er.property_value_point_estimate_final!=null) { return true; }
		
		boolean hasMinAndMax = er.property_value_min_final!=null && er.property_value_max_final!=null;
		if (!hasMinAndMax) { return false; }
		
		boolean good = true;
		
		double logTolerance = 1.0;//log units for properties that vary many orders of magnitude; if value was 1, then max would be 10x bigger than min
		double temperatureTolerance = 10.0;//C For Melting point, boiling point, flash point
		double densityTolerance = 0.1;//g/cm^3 for density
		double zeroTolerance = Math.pow(10.0, -6.0);
		
		if (er.property_name.equals(ExperimentalConstants.str_pKA) || er.property_name.equals(ExperimentalConstants.strLogKow)) {
			good = isWithinTolerance(er.property_value_min_final,er.property_value_max_final,logTolerance);
		} else if ((er.property_name.equals(ExperimentalConstants.strMeltingPoint) || er.property_name.equals(ExperimentalConstants.strBoilingPoint) ||
				er.property_name.equals(ExperimentalConstants.strFlashPoint))) {
			good = isWithinTolerance(er.property_value_min_final,er.property_value_max_final,temperatureTolerance);
		} else if (er.property_name.equals(ExperimentalConstants.strDensity)) {
			good = isWithinTolerance(er.property_value_min_final,er.property_value_max_final,densityTolerance);
		} else if (er.property_name.equals(ExperimentalConstants.strVaporPressure) || er.property_name.equals(ExperimentalConstants.strHenrysLawConstant) ||
				er.property_name.equals(ExperimentalConstants.strWaterSolubility) || er.property_name.toLowerCase().contains("lc50") ||
				er.property_name.toLowerCase().contains("ld50")) {
			good = isWithinLogTolerance(er.property_value_min_final,er.property_value_max_final,logTolerance,zeroTolerance);
		}
		
		return good;
	}

	private static boolean isWithinLogTolerance(double min,double max,double logTolerance,double zeroTolerance) {
		if (Math.abs(min) > zeroTolerance) {
			return Math.log10(max/min) <= logTolerance;
		} else {
			return false;
		}
	}

	private static boolean isWithinTolerance(double min,double max,double tolerance) {		
		return max-min <= tolerance;
	}

	private static double rangeAverage(ExperimentalRecord er) {
		return (er.property_value_min_final + er.property_value_max_final)/2.0;
	}
	
	public void assignValue(String fieldName,String fieldValue) {
		if (fieldValue.isEmpty()) return;
		Field myField;
		try {
			myField = getClass().getDeclaredField(fieldName);
			if (myField.getType().getName().contentEquals("boolean")) {
				myField.setBoolean(this, Boolean.parseBoolean(fieldValue));
			} else if (myField.getType().getName().contentEquals("double")) {
				myField.setDouble(this, Double.parseDouble(fieldValue));
			} else if (myField.getType().getName().contentEquals("int")) {
				myField.setInt(this, Integer.parseInt(fieldValue));
			} else if (myField.getType().getName().contentEquals("java.lang.Double")) {
				Double dval=Double.parseDouble(fieldValue);						
				myField.set(this, dval);
			} else if (myField.getType().getName().contentEquals("java.lang.Integer")) {
				Integer ival=Integer.parseInt(fieldValue);
				myField.setInt(this,ival);
			} else if (myField.getType().getName().contentEquals("java.lang.String")) {
				myField.set(this, fieldValue);
			} else {
				System.out.println("Need to implement"+myField.getType().getName());
			}					
		} catch (Exception e) {
			e.printStackTrace();
		} 
	}
	
	public static void writeListToExcelFile(List<RecordQSAR> qsarRecords,String filePath) {
		writeListToExcelFile(qsarRecords,RecordQSAR.outputFieldNames,filePath);
	}
	
	public static void writeListToExcelFile(List<RecordQSAR> qsarRecords,String[] fieldNames,String filePath) {
		String[] headers = fieldNames;
		Workbook wb = new XSSFWorkbook();
		Sheet recSheet = wb.createSheet("Records");
		Sheet badSheet = wb.createSheet("Records-Bad");
		Row recSubtotalRow = recSheet.createRow(0);
		Row recHeaderRow = recSheet.createRow(1);
		Row badSubtotalRow = badSheet.createRow(0);
		Row badHeaderRow = badSheet.createRow(1);
		CellStyle style = wb.createCellStyle();
		Font font = wb.createFont();
		font.setBoldweight(Font.BOLDWEIGHT_BOLD);
		style.setFont(font);
		for (int i = 0; i < headers.length; i++) {
			Cell recCell = recHeaderRow.createCell(i);
			recCell.setCellValue(headers[i]);
			recCell.setCellStyle(style);
			Cell badCell = badHeaderRow.createCell(i);
			badCell.setCellValue(headers[i]);
			badCell.setCellStyle(style);
		}
		int recCurrentRow = 2;
		int badCurrentRow = 2;
		Class clazz = RecordQSAR.class;
		for (RecordQSAR qr:qsarRecords) {
			try {
				Row row = null;
				if (qr.usable) {
					row = recSheet.createRow(recCurrentRow);
					recCurrentRow++;
				} else {
					row = badSheet.createRow(badCurrentRow);
					badCurrentRow++;
				}
				for (int i = 0; i < headers.length; i++) {
					Field field = clazz.getDeclaredField(headers[i]);
					Object value = field.get(qr);
					if (value!=null && !(value instanceof Double)) { 
						String strValue = ParseUtilities.reverseFixChars(StringEscapeUtils.unescapeHtml4(value.toString()));
						row.createCell(i).setCellValue(strValue);
					} else if (value!=null) { row.createCell(i).setCellValue((double) value); }
				}
			} catch (Exception ex) {
				ex.printStackTrace();
			}
		}
		
		String lastCol = CellReference.convertNumToColString(headers.length);
		recSheet.setAutoFilter(CellRangeAddress.valueOf("A2:"+lastCol+recCurrentRow));
		recSheet.createFreezePane(0, 2);
		badSheet.setAutoFilter(CellRangeAddress.valueOf("A2:"+lastCol+badCurrentRow));
		badSheet.createFreezePane(0, 2);
		
		for (int i = 0; i < headers.length; i++) {
			String col = CellReference.convertNumToColString(i);
			String recSubtotal = "SUBTOTAL(3,"+col+"$3:"+col+"$"+(recCurrentRow+1)+")";
			recSubtotalRow.createCell(i).setCellFormula(recSubtotal);
			String badSubtotal = "SUBTOTAL(3,"+col+"$3:"+col+"$"+(badCurrentRow+1)+")";
			badSubtotalRow.createCell(i).setCellFormula(badSubtotal);
		}
		
		try {
			OutputStream fos = new FileOutputStream(filePath);
			wb.write(fos);
			wb.close();
		} catch (Exception ex) {
			ex.printStackTrace();
		}
	}
}
